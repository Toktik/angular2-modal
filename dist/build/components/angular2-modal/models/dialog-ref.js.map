{"version":3,"file":"dialog-ref.js","sourceRoot":"","sources":["dialog-ref.ts"],"names":[],"mappings":";AACA,wBAAiC,kCAAkC,CAAC,CAAA;AAGpE;;GAEG;AACH;IAcI,mBAAmB,OAAW;QAAX,YAAO,GAAP,OAAO,CAAI;QAFtB,oBAAe,GAA0B,IAAI,0BAAgB,EAAO,CAAC;IAE3C,CAAC;IAMnC,sBAAI,6BAAM;QAJV;;;WAGG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC;QACxC,CAAC;;;OAAA;IAED;;OAEG;IACH,yBAAK,GAAL,UAAM,MAAkB;QAAxB,iBAQC;QARK,sBAAkB,GAAlB,aAAkB;QACpB,IAAM,MAAM,GAAG;YACX,KAAI,CAAC,OAAO,EAAE,CAAC;YACf,KAAI,CAAC,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACzC,CAAC,CAAC;QACF,IAAI,CAAC,SAAS,CAAU,aAAa,CAAC;aACjC,IAAI,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,KAAK,IAAI,IAAI,MAAM,EAAE,EAA1B,CAA0B,CAAE;aAC3C,KAAK,CAAC,MAAM,CAAC,CAAC;IACvB,CAAC;IAED;;;;;;OAMG;IACH,2BAAO,GAAP;QAAA,iBAQC;QAPG,IAAM,QAAQ,GAAG;YACb,KAAI,CAAC,OAAO,EAAE,CAAC;YACf,KAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;QAClC,CAAC,CAAC;QACF,IAAI,CAAC,SAAS,CAAU,eAAe,CAAC;aACnC,IAAI,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,KAAK,IAAI,IAAI,QAAQ,EAAE,EAA5B,CAA4B,CAAE;aAC7C,KAAK,CAAC,QAAQ,CAAC,CAAC;IACzB,CAAC;IAED,2BAAO,GAAP,cAAY,CAAC;IAEL,6BAAS,GAAjB,UAAqB,IAAqC;QACtD,IAAM,QAAQ,GAAyB,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAC5E,EAAE,GAAa,QAAQ,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,UAAU,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC;QAExF,MAAM,CAAC,OAAO,CAAC,OAAO,CAAE,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAE,CAAC;IAC7D,CAAC;IACL,gBAAC;AAAD,CAAC,AA9DD,IA8DC;AA9DY,iBAAS,YA8DrB,CAAA","sourcesContent":["import { ComponentRef } from '@angular/core';\nimport { PromiseCompleter } from '@angular/core/src/facade/promise';\nimport { ModalComponent } from '../models/tokens';\n\n/**\n * API to an open modal window.\n */\nexport class DialogRef<T> {\n    /** \n     * The reference to the component ref.\n     * @internal\n     * @return {ComponentRef<any>}\n     */\n    contentRef: ComponentRef<any>;\n\n    /**\n     * States if the modal is inside a specific element.\n     */\n    public inElement: boolean;\n    private _resultDeferred: PromiseCompleter<any> = new PromiseCompleter<any>();\n\n    constructor(public context?: T) { }\n\n    /**\n     * A Promise that is resolved on a close event and rejected on a dismiss event.\n     * @returns {Promise<T>|any|*|Promise<any>}\n     */\n    get result(): Promise<any> {\n        return this._resultDeferred.promise;\n    }\n\n    /**\n     *  Close the modal with a return value, i.e: result.\n     */\n    close(result: any = null) {\n        const _close = () => {\n            this.destroy();\n            this._resultDeferred.resolve(result);\n        };\n        this._fireHook<boolean>('beforeClose')\n            .then( value => value !== true && _close() )\n            .catch(_close);\n    }\n\n    /**\n     *  Close the modal without a return value, i.e: cancelled.\n     *  This call is automatically invoked when a user either:\n     *  - Presses an exit keyboard key (if configured).\n     *  - Clicks outside of the modal window (if configured).\n     *  Usually, dismiss represent a Cancel button or a X button.\n     */\n    dismiss() {\n        const _dismiss = () => {\n            this.destroy();\n            this._resultDeferred.reject();\n        };\n        this._fireHook<boolean>('beforeDismiss')\n            .then( value => value !== true && _dismiss() )\n            .catch(_dismiss);\n    }\n\n    destroy() { }\n\n    private _fireHook<T>(name: 'beforeClose' | 'beforeDismiss'): Promise<T> {\n        const instance: ModalComponent<this> = this.contentRef && this.contentRef.instance,\n              fn: Function = instance && typeof instance[name] === 'function' && instance[name];\n\n        return Promise.resolve( fn ? fn.call(instance) : false );\n    }\n}\n"]}