{"version":3,"file":"dialog-ref-stack.js","sourceRoot":"","sources":["dialog-ref-stack.ts"],"names":[],"mappings":";AAEA;;GAEG;AACH;IAAA;QACY,WAAM,GAAmB,EAAE,CAAC;IAqDxC,CAAC;IAlDG,6BAAI,GAAJ,UAAK,SAAuB;QACxB,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACzC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;YAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAChD,CAAC;IAED;;;;OAIG;IACH,oCAAW,GAAX,UAAY,SAAuB;QAAnC,iBAQC;QAPG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACrB,SAAS,CAAC,MAAM;aACX,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAtB,CAAsB,CAAC;aAClC,KAAK,CAAC,cAAM,OAAA,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,EAAtB,CAAsB,CAAC,CAAC;QACzC,+EAA+E;QAC/E,yFAAyF;QACzF,iBAAiB;IACrB,CAAC;IAED,4BAAG,GAAH;QACI,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;IACtB,CAAC;IAED;;;OAGG;IACH,+BAAM,GAAN,UAAO,SAAuB;QAC1B,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QACzC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;YAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC7C,CAAC;IAED,kCAAS,GAAT;QACI,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAA,SAAS;YACzB,SAAS,CAAC,KAAK,EAAE,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAED,8BAAK,GAAL,UAAM,KAAa;QACf,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAC9B,CAAC;IAED,gCAAO,GAAP,UAAQ,SAAuB;QAC3B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAC1C,CAAC;IAED,sBAAI,kCAAM;aAAV;YACI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAC9B,CAAC;;;OAAA;IACL,qBAAC;AAAD,CAAC,AAtDD,IAsDC;AAtDY,sBAAc,iBAsD1B,CAAA","sourcesContent":["import { DialogRef } from './dialog-ref';\n\n/**\n * A dumb stack implementation over an array.\n */\nexport class DialogRefStack<T> {\n    private _stack: DialogRef<T>[] = [];\n\n\n    push(dialogRef: DialogRef<T>): void {\n        let idx = this._stack.indexOf(dialogRef);\n        if (idx === -1) this._stack.push(dialogRef);\n    }\n\n    /**\n     * Push a DialogRef into the stack and manage it so when it's done\n     * it will automatically kick itself out of the stack.\n     * @param dialogRef\n     */\n    pushManaged(dialogRef: DialogRef<T>): void {\n        this.push(dialogRef);\n        dialogRef.result\n            .then(() => this.remove(dialogRef))\n            .catch(() => this.remove(dialogRef));\n        // we don't \"pop\" because we can't know for sure that our instance is the last.\n        // In a user event world it will be the last, but since modals can close programmatically\n        // we can't tell.\n    }\n\n    pop(): void {\n        this._stack.pop();\n    }\n\n    /**\n     * Remove a DialogRef from the stack.\n     * @param dialogRef\n     */\n    remove(dialogRef: DialogRef<T>): void {\n        let idx = this._stack.indexOf(dialogRef);\n        if (idx > -1) this._stack.splice(idx, 1);\n    }\n\n    removeAll():void {\n        this._stack.forEach(dialogRef => {\n            dialogRef.close();\n        });\n    }\n\n    index(index: number): DialogRef<T> {\n        return this._stack[index];\n    }\n\n    indexOf(dialogRef: DialogRef<T>): number {\n        return this._stack.indexOf(dialogRef);\n    }\n\n    get length(): number {\n        return this._stack.length;\n    }\n}\n"]}